{
  "version": 3,
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "statics",
    "ABORT",
    "track",
    "Environment",
    "select",
    "tracker",
    "fn",
    "lang",
    "Type",
    "isPromise",
    "value",
    "then",
    "__push",
    "newPromise",
    "promises",
    "undefined",
    "ex",
    "Error",
    "e",
    "push",
    "promise",
    "rejected",
    "self",
    "result",
    "event",
    "Utils",
    "reject",
    "__addCatcher",
    "__thenPromise",
    "__catcher",
    "bind",
    "err",
    "catchers",
    "catch1",
    "catch2",
    "callListener",
    "listener",
    "context",
    "tmp",
    "handler",
    "call",
    "getPropagationStopped",
    "series",
    "arr",
    "ignoreAbort",
    "index",
    "length",
    "Promise",
    "item"
  ],
  "sources": [
    "C:/Users/dadovaz/AppData/Roaming/npm/node_modules/@qooxdoo/framework/source/class/qx/event/Utils.js"
  ],
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2018 Zenesis Ltd, john.spackman@zenesis.com\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * John Spackman (johnspackman)\n\n************************************************************************ */\n\n/**\n * Utility methods which implement a fast, psuedo-promises mechanism used by event handlers\n * and dispatchers.\n *\n * Event handlers are allowed to return instances of `qx.Promise`, in which case the event\n * queue is suspended until the promise is resolved.  The simplest way to handle this would be\n * to convert the result of every event handler into a `qx.Promise` via `qx.Promise.resolve`,\n * but given that by far the majority of event handlers do not return promises, this could add\n * a significant overhead; the static methods in this class allow the event handlers to be\n * triggered and only when a `qx.Promise` is returned from a handler does the event dispatch\n * mechanism switch to using promise to suspend the event queue.\n *\n * To use this, the calling code simply creates an empty object (i.e. `var tracker = {};`)\n * which is then passed to `qx.event.Utils.then`, for example:\n *\n * <code>\n * var tracker = {};\n * Utils.then(tracker, function() { ... });\n * Utils.then(tracker, function() { ... });\n * Utils.then(tracker, function() { ... });\n * Utils.catch(tracker, function() { ... });\n * </code>\n *\n * Following with the morphing nature of this class, the return type will be either the value\n * returned from the event handlers, or a promise which evaluates to that value.\n *\n * When events are aborted (eg via `event.stopPropagation()`) that causes the promise (if there\n * is one) to be rejected.\n *\n * Note that this class is not a replacement for promises and has its limitations because it\n * has been built for the express purposes of the event dispatchers.\n *\n * @internal\n * @ignore(qx.Promise)\n * @ignore(Promise)\n */\nqx.Class.define(\"qx.event.Utils\", {\n  extend: qx.core.Object,\n\n  statics: {\n    ABORT: \"[[ qx.event.Utils.ABORT ]]\",\n\n    /**\n     * Evaluates a value, and adds it to the tracker\n     *\n     * @param tracker {Object} the tracker object\n     * @param fn {Function|Object?} if a function, it's evaluated as a `then`, otherwise\n     *  it's encapulated in a function for `then`\n     * @return {qx.Promise|Object?}\n     */\n    track: qx.core.Environment.select(\"qx.promise\", {\n      true(tracker, fn) {\n        if (typeof fn !== \"function\" && !qx.lang.Type.isPromise(fn)) {\n          fn = (function (value) {\n            return function () {\n              return value;\n            };\n          })(fn);\n        }\n        return this.then(tracker, fn);\n      },\n      false(tracker, fn) {\n        if (typeof fn === \"function\") {\n          return fn();\n        }\n        return fn;\n      }\n    }),\n\n    /**\n     * Helper method to store a promise in a tracker\n     *\n     * @param tracker {Object} the tracker object\n     * @param newPromise {qx.Promise} the new promise\n     * @return {qx.Promise} the new promise\n     */\n    __push(tracker, newPromise) {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        if (tracker.promises === undefined) {\n          tracker.promises = [];\n        }\n        var ex = null;\n        try {\n          throw new Error(\"\");\n        } catch (e) {\n          ex = e;\n        }\n        tracker.promises.push({ promise: newPromise, ex: ex });\n      }\n      tracker.promise = newPromise;\n      return tracker.promise;\n    },\n\n    /**\n     * Equivalent of `promise.then()`\n     *\n     * @param tracker {Object} the tracker object\n     * @param fn {Function} the function to call when previous promises are complete\n     * @return {qx.Promise?} the new promise, or the return value from `fn` if no promises are in use\n     */\n    then: qx.core.Environment.select(\"qx.promise\", {\n      true(tracker, fn) {\n        if (tracker.rejected) {\n          return null;\n        }\n        if (tracker.promise) {\n          if (qx.lang.Type.isPromise(fn)) {\n            this.__push(tracker, tracker.promise.then(fn));\n          } else {\n            var self = this;\n            this.__push(\n              tracker,\n              tracker.promise.then(function (result) {\n                if (tracker.rejected) {\n                  return null;\n                }\n                result = fn(result);\n                if (result === qx.event.Utils.ABORT) {\n                  return self.reject(tracker);\n                }\n                return result;\n              })\n            );\n          }\n          this.__addCatcher(tracker);\n          return tracker.promise;\n        }\n        if (qx.lang.Type.isPromise(fn)) {\n          return this.__thenPromise(tracker, fn);\n        }\n        var result = fn(tracker.result);\n        if (qx.lang.Type.isPromise(result)) {\n          return this.__thenPromise(tracker, result);\n        }\n        tracker.result = result;\n        if (result === qx.event.Utils.ABORT) {\n          return this.reject(tracker);\n        }\n\n        return result;\n      },\n\n      false(tracker, fn) {\n        if (tracker.rejected) {\n          return null;\n        }\n        var result = (tracker.result = fn(tracker.result));\n        if (result === qx.event.Utils.ABORT) {\n          return this.reject(tracker);\n        }\n        return result;\n      }\n    }),\n\n    /**\n     * Helper method to append a promise after the current one\n     *\n     * @param tracker {Object} the tracker object\n     * @param newPromise {qx.Promise} the new promise\n     * @return {qx.Promise} the new promise\n     */\n    __thenPromise(tracker, newPromise) {\n      if (tracker.promise) {\n        this.__push(\n          tracker,\n          tracker.promise.then(function () {\n            return newPromise;\n          })\n        );\n      } else {\n        this.__push(tracker, newPromise);\n      }\n      this.__addCatcher(tracker);\n      return tracker.promise;\n    },\n\n    /**\n     * Rejects the tracker, aborting the promise if there is one.  The caller should stop\n     * immediately because if promises are not in use and exception is not thrown.\n     *\n     * @param tracker {Object} the tracker object\n     * @return {qx.Promise?} the last promise or the value returned by the catcher\n     */\n    reject(tracker) {\n      if (tracker.rejected) {\n        return qx.event.Utils.ABORT;\n      }\n      tracker.rejected = true;\n\n      if (tracker.promise) {\n        throw new Error(\"Rejecting Event\");\n      }\n      var result = this.__catcher(tracker);\n      return result === undefined ? this.ABORT : result;\n    },\n\n    /**\n     * Helper method that adds a catcher to the tracker\n     *\n     * @param tracker {Object} the tracker object\n     */\n    __addCatcher(tracker) {\n      if (tracker.promise && tracker.catch) {\n        if (!tracker.promise[\"qx.event.Utils.hasCatcher\"]) {\n          this.__push(\n            tracker,\n            tracker.promise.catch(this.__catcher.bind(this, tracker))\n          );\n\n          tracker.promise[\"qx.event.Utils.hasCatcher\"] = true;\n        }\n      }\n    },\n\n    /**\n     * This method is added with `.catch` to every promise created; because this is added\n     * all the way up the promise chain to ensure that it catches everything, this method\n     * supresses multiple invocations (i.e. ignores everything except the first)\n     *\n     * @param tracker {Object} the tracker object\n     */\n    __catcher(tracker, err) {\n      var fn = tracker.catch;\n      if (fn) {\n        tracker.catch = null;\n        tracker.rejected = true;\n        return fn(err);\n      }\n      return qx.event.Utils.ABORT;\n    },\n\n    /**\n     * Equivalent to `.catch()`; note that unlike promises, this method must be called *before*\n     * `.then()` so that it is able to handle rejections when promises are not in use; this is\n     * because `Promise.catch` only catches rejections from previous promises, but because promises\n     * are *always* asynchronous the `.catch` goes at the end.  For synchronous, this is nt possible\n     * so `Utils.catch` must go before `Utils.then`\n     *\n     * @param tracker {Object} the tracker object\n     * @param fn {Function} the function to call\n     */\n    catch(tracker, fn) {\n      if (tracker.rejected) {\n        fn();\n        return;\n      }\n\n      if (tracker.catchers === undefined) {\n        tracker.catchers = [fn];\n      } else {\n        tracker.catchers.push(fn);\n      }\n\n      if (tracker.catch) {\n        tracker.catch = (function (catch1, catch2) {\n          return function () {\n            catch1();\n            catch2();\n          };\n        })(tracker.catch, fn);\n      } else {\n        tracker.catch = fn;\n      }\n      this.__addCatcher(tracker);\n    },\n\n    /**\n     * Calls a listener, converting propagationStopped into a rejection\n     *\n     * @param tracker {Object} the tracker object\n     * @param listener {Function} the event handler\n     * @param context {Object?} the `this` for the event handler\n     * @param event {Event} the event being fired\n     * @returns {qx.Promise|?} the result of the handler\n     */\n    callListener(tracker, listener, context, event) {\n      if (tracker.rejected) {\n        return qx.event.Utils.ABORT;\n      }\n      var tmp = listener.handler.call(context, event);\n      if (event.getPropagationStopped()) {\n        return qx.event.Utils.ABORT;\n      }\n      return tmp;\n    },\n\n    /**\n     * Provides a handy way to iterate over an array which at any point could\n     * become asynchronous\n     *\n     * @param arr {Array} an array to interate over\n     * @param fn {Function?} the function to call, with parameters (item, index)\n     * @param ignoreAbort {Boolean?} whether to ignore the \"ABORT\" return value\n     * @return {qx.Promise|Object?}\n     */\n    series: qx.core.Environment.select(\"qx.promise\", {\n      true(arr, fn, ignoreAbort) {\n        var tracker = {};\n        for (var index = 0; index < arr.length; index++) {\n          var result = fn(arr[index], index);\n          if (qx.Promise.isPromise(result)) {\n            for (++index; index < arr.length; index++) {\n              (function (item, index) {\n                result = result.then(function () {\n                  var tmp = fn(item, index);\n                  if (!ignoreAbort && tmp === qx.event.Utils.ABORT) {\n                    throw new Error(\"Rejecting in series()\");\n                  }\n                  return tmp;\n                });\n              })(arr[index], index);\n            }\n            return result;\n          }\n\n          if (!ignoreAbort && result === qx.event.Utils.ABORT) {\n            return this.reject(tracker);\n          }\n        }\n\n        return null;\n      },\n\n      false(arr, fn, ignoreAbort) {\n        var tracker = {};\n        for (var index = 0; index < arr.length; index++) {\n          var result = fn(arr[index], index);\n          if (!ignoreAbort && result === qx.event.Utils.ABORT) {\n            return this.reject(tracker);\n          }\n        }\n      }\n    })\n  }\n});\n"
  ],
  "mappings": "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"
}